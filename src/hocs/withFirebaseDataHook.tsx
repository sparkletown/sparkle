import { useMemo } from "react";
import { ObservableStatus } from "reactfire";

const getDisplayName = <T,>(WrappedComponent: React.ComponentType<T>) => {
  return WrappedComponent.displayName || WrappedComponent.name || "Component";
};

interface WithFirebaseDataHookOptions<T> {
  loading?: React.ComponentType<T>;
  error?: React.ComponentType<T>;
}

/**
 * This functions creates a higher - order component that can be used to fetch
 * and listen to data from firebase using hooks.
 *
 * This effectively abstracts away the loading and error handling part of using
 * hooks for listening to data from firebase.
 *
 * The returned function accepts a component and a set of options as arguments.
 * When the hook has completed successfully the component is rendered and the
 * results of `transformFn` are merged with the passed in `props` and then
 * passed to the wrapped component.
 *
 * In the event that the hook fails the componentin `options.error` will be
 * rendered (with props passed).
 *
 * Whilst the hook is loading the component in `options.loading` will be
 * rendered (with props passed).
 *
 * The props passed to the component and the props created by `transformFn`
 * should not have overlapping keys.
 *
 * @param useFn - a hook that returns an ObserverableStatus.Typically by using
 * useFirestoreCollectionData or a similar method.
 * @param transformFn - A function that is called after the hook has completed.
 * It transforms the data property of the hook's result.
 */
export const withFirebaseDataHook = <
  QueryDataType,
  TransformedDataType,
  UseArgsType
>(
  useFn: (props: UseArgsType) => ObservableStatus<QueryDataType>,
  transformFn: (data: QueryDataType) => TransformedDataType
) => {
  // The types here are gnarly. Essentially, we want the wrapper component that
  // is generated to have the same props as the wrapped component with the
  // exception of the props that are generated by the transformation function.
  const hocFn = <PropsType extends UseArgsType>(
    WrappedComponent: React.ComponentType<PropsType>,
    options?: WithFirebaseDataHookOptions<
      Omit<PropsType, keyof TransformedDataType>
    >
  ) => {
    const WithFirebaseDataHook = (
      props: Omit<PropsType, keyof TransformedDataType> & UseArgsType
    ) => {
      const { data, status, error } = useFn(props);

      const transformedData = useMemo(() => {
        if (status === "loading" || error) {
          return;
        }
        return transformFn(data);
      }, [data, status, error]);

      if (status === "loading") {
        if (options?.loading) {
          return <options.loading {...props} />;
        }
        return <></>;
      }

      if (error) {
        console.error(error);
        if (options?.error) {
          return <options.error {...props} />;
        }
        return <></>;
      }

      // I could not convince typescript to compile without casting through to
      // unknown first. I imagine someone smarter than me will figure out the
      // right generics to make this work. In the mean time, the mess is contained
      // to one line and the API presented by this is clean.
      const mergedProps = {
        ...props,
        ...transformedData,
      } as unknown as PropsType;
      return <WrappedComponent {...mergedProps} />;
    };
    WithFirebaseDataHook.displayName = `WithFirebaseDataHook(${getDisplayName(
      WrappedComponent
    )}}`;
    return WithFirebaseDataHook;
  };
  return hocFn;
};
